
#include ../std_lib/std_lib.cmm
#include ../std_lib/shift.cmm
#include ../std_lib/sleep.cmm
#include ../std_lib/math.cmm
#include ../std_lib/video.cmm
#include ../std_lib/print.cmm

char buffer[40*30];

int changed_index = 0;
int changed[64];

int memset(char* destination int length char value) {
    int i = 0;
    while(i < length) {
        destination[i] = value;
        i = i + 1;
    }
}

int add_changed(int index) {

    //out (left_shift_i(changed_index 4) | index 0);
    out (changed_index 0);
    changed[changed_index] = index;
    changed_index = changed_index + 1;
}

int calc_next_gen() {

    // Set up tile position variables
    int tile = 0;
    int tile_x = 0;
    int tile_y = 0;

    // Iterate over all tiles
    while (tile < VIDEO_TILES) {
        
        int neighbor_count = 0;
        int y = -1;

        // Iterate over offsets for x and y: -1, 0, 1
        while (y < 2) {
            
            int x = -1;
            while (x < 2) {
                
                // If not in the middle
                if ((x == 0) & (x == 0)) continue 0;

            
                // Acquire position adjusted for wrapping
                int pos_x = tile_x + x;
                int pos_y = tile_y + y;

                // Adjust x
                if (pos_x >= VIDEO_TILE_WIDTH) {
                    pos_x = 0;
                } else if (pos_x < 0) {
                    pos_x = VIDEO_TILE_WIDTH - 1;
                }

                // Adjust y
                if (pos_y >= VIDEO_TILE_HEIGHT) {
                    pos_y = 0;
                } else if (pos_y < 0) {
                    pos_y = VIDEO_TILE_HEIGHT - 1;
                }
            
                int position = pos_x + (VIDEO_TILE_WIDTH * pos_y);

                // If tile contains a neighbor, up the neighbor count
                neighbor_count = neighbor_count + buffer[position];

                x = x + 1;       

            }

            y = y + 1;
        }

        if (buffer[tile]) {
            
            // Solitude and overpopulation
            if ((neighbor_count < 2) | (neighbor_count > 3)) {
                add_changed(tile);
                out (0xD000 | tile 0);
            }

        } else {
            
            if (neighbor_count == 3) {
                add_changed(tile);
            }
        }

        // Increment tile
        tile_x = tile_x + 1;
        tile = tile + 1;

        if (tile_x >= VIDEO_TILE_WIDTH) {
            tile_x = 0;
            tile_y = tile_y + 1;
        }
    }

}

int print_tile(int index) {

    if (buffer[index]) {
        BG_COLOR = 3;
        out (0xDEEF 0);
    } else {
        BG_COLOR = 0;
    }

    print_c_at('\0' index);
}

int print_board() {

    int i = 0;

    if (i != 0) i = 0;

    while (i < 1200) {
        print_tile(i);        
        i = i + 1;
    }
}

int update_changed() {

    int i = 0;
    while (i < changed_index) {
        int tile_index = changed[i];

        out(0xFFFF 0);
        
        if (buffer[tile_index]) {
            buffer[tile_index] = 0;
            out(0xDDDD 0);
        } else {
            out(0xAAAA 0);
            buffer[tile_index] = 1;
        }

        i = i + 1;
    }

    changed_index = 0;
}

int next_gen() {
    calc_next_gen();
    update_changed();
}

int main() {

    // Reset buffer
    //memset(buffer VIDEO_TILES 0);

    out(0xDEAD 0);

    // Draw glider in top left corner
    /*add_changed(42);
    add_changed(83);
    add_changed(121);
    add_changed(122);
    add_changed(123);*/

    buffer[42] = 1;
    buffer[83] = 1;
    buffer[121] = 1;
    buffer[122] = 1;
    buffer[123] = 1;

    /*changed[changed_index] = 42;
    changed_index = changed_index + 1;

    changed[changed_index] = 83;
    changed_index = changed_index + 1;
    
    changed[changed_index] = 121;
    changed_index = changed_index + 1;
    
    changed[changed_index] = 122;
    changed_index = changed_index + 1;
    
    changed[changed_index] = 123;
    changed_index = changed_index + 1;*/
    

    //update_changed();
    print_board();

    int gen_count = 0;
    while (1) {
        //out(gen_count 0);
        sleep_ms(1000);
        next_gen();
        print_board();
        gen_count = gen_count + 1;
    }
}

